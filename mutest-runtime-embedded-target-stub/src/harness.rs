use core::cell::Cell;
use core::fmt::{self, Debug};

use crate::metadata::{MetaMutant, SubstLocIdx, SubstMap, SubstMeta, TestSuite};

/// Handle storing the currently active substitution map of a program.
///
/// An instance of this handle is automatically created and referenced in
/// meta-mutant programs generated by mutest-rs.
///
/// # Safety
///
/// All valid uses of this handle must be stored in a `static` (or any pinned memory location).
///
/// Reading from this handle remains valid even as the substitution map stored in the handle
/// is changed or swapped out, as it represents a static memory location.
/// For example, it is considered valid for a read from the handle to
/// return substitution metadata from either the new or the possibly stale substitution maps
/// if the handle is simultaneously modified from another thread.
pub struct ActiveMutantHandle<S: SubstMap>(Cell<Option<S>>);

impl<S: SubstMap> ActiveMutantHandle<S> {
    pub const fn empty() -> Self {
        Self(Cell::new(None))
    }

    pub const fn with(v: S) -> Self {
        Self(Cell::new(Some(v)))
    }

    #[inline]
    pub fn subst_at(self: &'static Self, subst_loc_idx: SubstLocIdx) -> Option<SubstMeta> {
        // SAFETY: We are acquiring a reference to the static memory location backing the handle
        //         and the value is allowed to change before the substitution metadata is read.
        let subst_map_ref = (unsafe { &*self.0.as_ptr() }).as_ref();

        subst_map_ref.and_then(|subst| subst.subst_at(subst_loc_idx))
    }

    /// # Safety
    ///
    /// The substitution location index must be valid for the active substitution map.
    #[inline]
    pub unsafe fn subst_at_unchecked(self: &'static Self, subst_loc_idx: SubstLocIdx) -> Option<SubstMeta> {
        // SAFETY: We are acquiring a reference to the static memory location backing the handle
        //         and the value is allowed to change before the substitution metadata is read.
        let subst_map_ref = (unsafe { &*self.0.as_ptr() }).as_ref();

        // SAFETY: The caller must ensure that the substitution location index is
        //         valid for the active substitution map.
        subst_map_ref.and_then(|subst| unsafe { subst.subst_at_unchecked(subst_loc_idx) })
    }

    /// # Safety
    ///
    /// The caller must ensure that no other thread is reading from the handle.
    pub(crate) unsafe fn replace(&self, v: Option<S>) {
        self.0.replace(v);
    }
}

// SAFETY: While access to the handle data is not synchronized, the handle can only be mutated using
//         unsafe, crate-private functions, see above.
unsafe impl<S: SubstMap> Sync for ActiveMutantHandle<S> {}

impl<S: SubstMap> Debug for ActiveMutantHandle<S> {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt.debug_tuple("ActiveMutantHandle")
            .field(&format_args!("_"))
            .finish()
    }
}

pub fn mutest_main_static(_test_suite: TestSuite, _meta_mutant: &'static MetaMutant<impl SubstMap>) {
    todo!("mutest_runtime_embedded_target_stub::mutest_main_static");
}
